#!/usr/bin/env python3
"""
novel_downloader.apps.cli.commands.clean
----------------------------------------
"""

import shutil
from argparse import ArgumentParser, Namespace, _SubParsersAction
from pathlib import Path

from novel_downloader.apps.cli import ui
from novel_downloader.apps.utils import load_or_init_config
from novel_downloader.infra.config import ConfigAdapter
from novel_downloader.infra.i18n import t
from novel_downloader.infra.paths import PACKAGE_NAME, STATE_PATH
from novel_downloader.plugins import registrar
from novel_downloader.schemas import BookConfig

from .base import Command


class CleanCmd(Command):
    name = "clean"
    help = t("Clear application logs, caches, and book data")

    @classmethod
    def register(cls, subparsers: "_SubParsersAction[ArgumentParser]") -> None:
        parser = subparsers.add_parser(cls.name, help=cls.help)
        sub = parser.add_subparsers(dest="subcommand", required=True)

        for subcmd in (CleanStateCmd, CleanLogsCmd, CleanCacheCmd, CleanBookCmd):
            subcmd.register(sub)

    @classmethod
    def run(cls, args: Namespace) -> None:
        raise NotImplementedError("CleanCmd should not be executed directly")


class CleanStateCmd(Command):
    name = "state"
    help = t("Clean internal state (runtime state, temp info).")

    @classmethod
    def add_arguments(cls, parser: ArgumentParser) -> None:
        parser.add_argument(
            "-y", "--yes", action="store_true", help=t("Skip confirmation prompt")
        )

    @classmethod
    def run(cls, args: Namespace) -> None:
        if not STATE_PATH.exists():
            ui.info(t("No internal state found. Nothing to clean."))
            return

        ui.info(t("Internal state file: {path}").format(path=STATE_PATH))

        if not args.yes:
            question = t("Are you sure you want to remove internal state?")
            if not ui.confirm(question, default=False):
                ui.warn(t("Cancelled."))
                return

        try:
            STATE_PATH.unlink()
            ui.success(t("Internal state removed successfully."))
        except Exception as exc:
            ui.error(t("Failed to remove internal state: {error}").format(error=exc))
            return

        parent = STATE_PATH.parent
        try:
            if parent.exists() and not any(parent.iterdir()):
                parent.rmdir()
        except Exception:
            pass


class CleanLogsCmd(Command):
    name = "logs"
    help = t("Clean log files generated by the application.")

    @classmethod
    def add_arguments(cls, parser: ArgumentParser) -> None:
        parser.add_argument(
            "--config", type=str, help=t("Path to the configuration file")
        )
        parser.add_argument(
            "-y", "--yes", action="store_true", help=t("Skip confirmation prompt")
        )
        parser.add_argument(
            "--dry-run",
            action="store_true",
            help=t("Show what would be removed without deleting anything."),
        )

    @classmethod
    def run(cls, args: Namespace) -> None:
        config_path: Path | None = Path(args.config) if args.config else None
        config_data = load_or_init_config(config_path)
        if config_data is None:
            return

        adapter = ConfigAdapter(config=config_data)
        log_dir = adapter.get_log_dir()

        if not log_dir.exists():
            ui.info(t("Log directory does not exist: {path}").format(path=log_dir))
            return

        if not log_dir.is_dir():
            ui.error(t("Log path is not a directory: {path}").format(path=log_dir))
            return

        prefix = f"{PACKAGE_NAME}."
        log_files = [
            f for f in log_dir.iterdir() if f.is_file() and f.name.startswith(prefix)
        ]

        if not log_files:
            ui.info(t("No log files to clean in {path}.").format(path=log_dir))
            return

        ui.info(
            t("Found {count} log files to clean in {path}.").format(
                count=len(log_files), path=log_dir
            )
        )

        if args.dry_run:
            ui.info(t("Dry-run mode: The following files would be removed:"))
            for f in log_files:
                ui.info(f"  - {f.name}")
            return

        if not args.yes:
            question = t("Are you sure you want to remove these log files?")
            if not ui.confirm(question, default=False):
                ui.warn(t("Cancelled."))
                return

        removed_count = 0
        for file in log_files:
            try:
                file.unlink()
                removed_count += 1
                ui.info(t("Removed log file: {file}").format(file=file.name))
            except Exception as exc:
                ui.error(
                    t("Failed to remove log file {file}: {error}").format(
                        file=file.name, error=exc
                    )
                )

        if removed_count > 0:
            ui.success(
                t("Successfully removed {count} log files.").format(count=removed_count)
            )
        else:
            ui.warn(t("No log files were removed."))


class CleanCacheCmd(Command):
    name = "cache"
    help = t(
        "Clean cached data for a specific site, or all sites if no site is specified."
    )

    @classmethod
    def add_arguments(cls, parser: ArgumentParser) -> None:
        parser.add_argument(
            "--config", type=str, help=t("Path to the configuration file")
        )
        parser.add_argument(
            "--site",
            help=t("Source site key"),
        )
        parser.add_argument(
            "-y", "--yes", action="store_true", help=t("Skip confirmation prompt")
        )

    @classmethod
    def run(cls, args: Namespace) -> None:
        config_path: Path | None = Path(args.config) if args.config else None
        config_data = load_or_init_config(config_path)
        if config_data is None:
            return

        adapter = ConfigAdapter(config=config_data)
        cache_base = adapter.get_cache_dir()

        if args.site:
            target_dir = cache_base / args.site
            target_desc = t("site cache for '{site}'").format(site=args.site)
        else:
            target_dir = cache_base
            target_desc = t("all site caches")

        if not target_dir.exists():
            ui.info(
                t("No cache found for {desc} at {path}.").format(
                    desc=target_desc, path=target_dir
                )
            )
            return

        ui.info(t("Cache directory to clean: {path}").format(path=str(target_dir)))

        if not args.yes:
            question = t("Are you sure you want to remove {desc}?").format(
                desc=target_desc
            )
            if not ui.confirm(question, default=False):
                ui.warn(t("Cancelled."))
                return

        try:
            shutil.rmtree(target_dir, ignore_errors=True)
            ui.success(t("Successfully removed {desc}.").format(desc=target_desc))
        except Exception as exc:
            ui.error(
                t("Failed to remove {desc}: {error}").format(
                    desc=target_desc, error=exc
                )
            )


class CleanBookCmd(Command):
    name = "book"
    help = t("Clean cached raw data for one or more books.")

    @classmethod
    def add_arguments(cls, parser: ArgumentParser) -> None:
        parser.add_argument("book_ids", nargs="*", help=t("Book ID(s)"))
        parser.add_argument(
            "--site",
            help=t("Source site key"),
        )
        parser.add_argument(
            "--config", type=str, help=t("Path to the configuration file")
        )
        parser.add_argument(
            "--start",
            type=str,
            help=t("Start chapter ID (applies only to the first book)"),
        )
        parser.add_argument(
            "--end",
            type=str,
            help=t("End chapter ID (applies only to the first book)"),
        )
        parser.add_argument(
            "--stage",
            type=str,
            default="raw",
            help=t("Cleanup stage (e.g. 'raw', 'cleaned'). Defaults to 'raw'."),
        )

        parser.add_argument(
            "--no-chapters",
            action="store_true",
            help=t("Do not remove chapter data."),
        )
        parser.add_argument(
            "--metadata",
            action="store_true",
            help=t("Remove metadata JSON."),
        )
        parser.add_argument(
            "--media",
            action="store_true",
            help=t("Remove media resources (images, etc)."),
        )
        parser.add_argument(
            "--all",
            action="store_true",
            help=t("Remove all raw data for the book (ignore other flags)."),
        )
        parser.add_argument(
            "-y", "--yes", action="store_true", help=t("Skip confirmation prompt")
        )

    @classmethod
    def run(cls, args: Namespace) -> None:
        if args.all and not args.book_ids:
            cls._remove_all(args)
            return

        cls._remove_book(args)

    @classmethod
    def _remove_all(cls, args: Namespace) -> None:
        config_path: Path | None = Path(args.config) if args.config else None
        config_data = load_or_init_config(config_path)
        if config_data is None:
            return

        adapter = ConfigAdapter(config=config_data)
        raw_data_base = adapter.get_raw_data_dir()

        if args.site:
            target_dir = raw_data_base / args.site
            desc = t("all data for site '{site}'").format(site=args.site)
        else:
            target_dir = raw_data_base
            desc = t("all raw data for all sites")

        if not target_dir.exists():
            ui.info(
                t("No data found for {desc} at {path}.").format(
                    desc=desc, path=target_dir
                )
            )
            return

        ui.info(t("Directory to clean: {path}").format(path=str(target_dir)))

        if not args.yes and not ui.confirm(
            t("Are you sure you want to remove {desc}?").format(desc=desc),
            default=False,
        ):
            ui.warn(t("Cancelled."))
            return

        try:
            shutil.rmtree(target_dir, ignore_errors=True)
            ui.success(t("Successfully removed {desc}.").format(desc=desc))
        except Exception as exc:
            ui.error(t("Failed to remove {desc}: {error}").format(desc=desc, error=exc))

    @classmethod
    def _remove_book(cls, args: Namespace) -> None:
        books = cls._parse_book_args(args.book_ids, args.start, args.end)

        if not books:
            ui.warn(t("No book IDs provided. Exiting."))
            return

        # Determine site
        site: str | None = args.site
        if not site:
            site = ui.prompt(t("Please enter the site key for these book(s):")).strip()
            if not site:
                ui.warn(t("No site provided."))
                return

        # Load config
        config_path: Path | None = Path(args.config) if args.config else None
        config_data = load_or_init_config(config_path)
        if config_data is None:
            return

        adapter = ConfigAdapter(config=config_data)
        client = registrar.get_client(site, adapter.get_client_config(site))

        remove_all = args.all

        remove_chapters = not args.no_chapters
        remove_metadata = args.metadata or False
        remove_media = args.media or False

        stage = args.stage or "raw"

        if remove_all:
            if not args.yes:
                q = t("Remove ALL raw data for {count} book(s)?").format(
                    count=len(books)
                )
                if not ui.confirm(q, default=False):
                    ui.warn(t("Cancelled."))
                    return

            for book in books:
                ui.info(
                    t("Removing all data for book '{id}'...").format(id=book.book_id)
                )
                try:
                    client.cleanup_book(
                        book,
                        remove_all=True,
                        stage=stage,
                    )
                except Exception as exc:
                    ui.error(
                        t("Failed to clean book '{id}': {error}").format(
                            id=book.book_id, error=exc
                        )
                    )

            ui.success(t("Finished cleaning all requested books."))
            return

        summary = []
        if remove_chapters:
            summary.append(t("chapters"))
        if remove_metadata:
            summary.append(t("metadata"))
        if remove_media:
            summary.append(t("media"))

        ui.info(
            t("Preparing to remove: {what}").format(
                what=", ".join(summary) if summary else t("nothing")
            )
        )

        if not args.yes:
            q = t("Proceed with removing {what} for {count} book(s)?").format(
                what=", ".join(summary),
                count=len(books),
            )
            if not ui.confirm(q, default=False):
                ui.warn(t("Cancelled."))
                return

        for book in books:
            ui.info(t("Cleaning book '{id}'...").format(id=book.book_id))
            try:
                client.cleanup_book(
                    book,
                    remove_chapters=remove_chapters,
                    remove_metadata=remove_metadata,
                    remove_media=remove_media,
                    stage=stage,
                )
            except Exception as exc:
                ui.error(
                    t("Failed to clean book '{id}': {error}").format(
                        id=book.book_id, error=exc
                    )
                )

        ui.success(t("Finished cleaning all requested books."))

    @staticmethod
    def _parse_book_args(
        book_ids: list[str],
        start_id: str | None,
        end_id: str | None,
    ) -> list[BookConfig]:
        """
        Convert CLI arguments into a list of `BookConfig`.
        """
        if not book_ids:
            return []

        result: list[BookConfig] = []
        result.append(
            BookConfig(
                book_id=book_ids[0],
                start_id=start_id,
                end_id=end_id,
            )
        )

        for book_id in book_ids[1:]:
            result.append(BookConfig(book_id=book_id))

        return result
